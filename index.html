<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phi2X : Th√©orie de l'Interf√©rence Harmonique Universelle</title>
    <script src="frd/marked.min.js"></script>
    <link rel="stylesheet" href="frd/github-dark.min.css">
    <script src="frd/highlight.min.js"></script>
    <link rel="stylesheet" href="frd/katex.min.css">
    <script defer src="frd/katex.min.js"></script>
    <script defer src="frd/auto-render.min.js"></script>
    <script src="frd/nostr.bundle.js"></script>
    <script src="frd/mermaid.min.js"></script>
    <style>
        :root { --bg: #0d1117; --fg: #f0f6fc; --accent: #ffd700; --blue: #58a6ff; --border: #30363d; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); color: var(--fg); line-height: 1.6; margin: 0; }
        .header { background: #161b22; border-bottom: 1px solid var(--border); padding: 8px 15px; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; }
        .header-nav { display: flex; align-items: center; justify-content: space-between; }
        .header-left { display: flex; align-items: center; gap: 10px; }
        .header-center { flex: 1; text-align: center; }
        .header-right { display: flex; align-items: center; gap: 8px; }
        .header h1 { color: var(--accent); margin: 0; font-size: 1.1rem; }
        .header-icon { background: #21262d; color: var(--blue); border: 1px solid var(--border); padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; text-decoration: none; transition: background 0.2s; }
        .header-icon:hover { background: #30363d; text-decoration: none; }
        .breadcrumb { color: #8b949e; font-size: 0.8rem; margin-left: 8px; position: relative; }
        .nav-menu { position: relative; display: inline-block; }
        .nav-dropdown { display: none; position: absolute; top: 100%; left: 0; background: #21262d; border: 1px solid var(--border); border-radius: 6px; min-width: 200px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .nav-dropdown.show { display: block; }
        .nav-dropdown a { display: block; padding: 8px 12px; color: var(--fg); text-decoration: none; border-bottom: 1px solid var(--border); transition: background 0.2s; }
        .nav-dropdown a:hover { background: #30363d; }
        .nav-dropdown a:last-child { border-bottom: none; }
        .nav-section-title { padding: 8px 12px; font-weight: bold; color: #58a6ff; border-top: 1px solid var(--border); margin-top: 4px; font-size: 0.9em; background: #161b22; }
        .nav-subsection a { padding-left: 24px; font-size: 0.9em; }
        .nav-subsection a:hover { background: #2d333b; }
        .nav-menu-btn { background: none; border: none; color: var(--blue); cursor: pointer; font-size: 0.8rem; padding: 2px 6px; border-radius: 3px; }
        .nav-menu-btn:hover { background: #30363d; }
        .connect-btn { background: linear-gradient(45deg, #9c27b0, #7b1fa2); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; text-decoration: none; transition: all 0.2s; }
        .connect-btn:hover { background: linear-gradient(45deg, #7b1fa2, #6a1b9a); text-decoration: none; color: white; }
        .connect-btn.connected { background: linear-gradient(45deg, #4CAF50, #45a049); }
        .copy-btn { background: linear-gradient(45deg, #ff6b6b, #ff5252); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; text-decoration: none; transition: all 0.2s; margin-left: 8px; }
        .copy-btn:hover { background: linear-gradient(45deg, #ff5252, #f44336); text-decoration: none; color: white; }
        .copy-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        body { padding-top: 60px; }
        .container { max-width: 1000px; margin: 0 auto; padding: 20px; }
        .markdown-content { background: var(--bg); }
        .markdown-content h1 { color: var(--accent); border-bottom: 2px solid var(--border); padding-bottom: 10px; margin-bottom: 30px; }
        .markdown-content h2 { color: var(--blue); margin-top: 40px; margin-bottom: 20px; }
        .markdown-content h3 { color: var(--fg); margin-top: 30px; margin-bottom: 15px; }
        .markdown-content code { background: #161b22; padding: 2px 6px; border-radius: 3px; color: var(--accent); }
        .markdown-content pre { background: #161b22; padding: 16px; border-radius: 6px; overflow-x: auto; margin: 20px 0; border: 1px solid var(--border); }
        .markdown-content pre code { background: none; padding: 0; color: var(--fg); }
        .markdown-content a { color: var(--blue); text-decoration: none; }
        .markdown-content a:hover { text-decoration: underline; }
        .markdown-content blockquote { border-left: 4px solid var(--accent); padding-left: 16px; margin: 20px 0; background: #161b22; padding: 16px; border-radius: 6px; font-style: italic; }
        .markdown-content table { border-collapse: collapse; width: 100%; margin: 20px 0; background: #161b22; border-radius: 6px; overflow: hidden; }
        .markdown-content th, .markdown-content td { border: 1px solid var(--border); padding: 12px; text-align: left; }
        .markdown-content th { background: #21262d; color: var(--accent); font-weight: 600; }
        .markdown-content ul, .markdown-content ol { margin: 16px 0; padding-left: 30px; }
        .markdown-content li { margin-bottom: 8px; }
        .loading { text-align: center; padding: 60px; color: #8b949e; }
        @media (max-width: 768px) { 
            .container { padding: 10px; } 
            .header-nav { padding: 0 5px; }
            .header h1 { font-size: 1rem; }
            .breadcrumb #breadcrumbText { display: none; }
            .header-right span { display: none; }
            .nav-dropdown { min-width: 180px; right: 0; left: auto; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-nav">
            <div class="header-left">
                <a id="backBtn" onclick="loadReadme()" class="header-icon" style="display: none;" title="Retour au README">üè†</a>
                <div id="breadcrumb" class="breadcrumb">
                    <div class="nav-menu">
                        <button id="navMenuBtn" class="nav-menu-btn" onclick="toggleNavMenu()">üìÑ Navigation ‚ñº</button>
                        <div id="navDropdown" class="nav-dropdown">
                            <!-- Menu items will be populated by JavaScript -->
                        </div>
                    </div>
                    <span id="breadcrumbText"></span>
                </div>
            </div>
            <div class="header-center">
                <button id="connectBtn" class="connect-btn" onclick="connectToNostr()">üîó Connect</button>
                <button id="copyBtn" class="copy-btn" onclick="copyToUDrive()" disabled>üìã Copier</button>
            </div>
            <div class="header-right">
                <span style="font-size: 0.7rem; color: #6e7681;">2025-09-24 19:13:15 UTC</span>
                <a href="/ipns/12D3KooWHTSu2e7shxtoNmCkLV1Nax1MDtnaJfwBng8tSX9DKtxu" class="header-icon" title="IPFS Node: 12D3KooWHTSu2e7shxtoNmCkLV1Nax1MDtnaJfwBng8tSX9DKtxu">üåê</a>
                <a href="/ipfs/QmfH21oALxCVgTshk38iciPPx5nfnE84SBjixgPCcGEF2K/" class="header-icon" id="prevVersionBtn" title="Version pr√©c√©dente">‚èÆÔ∏è</a>
                <a href="/ipfs/QmT6gZgaNhJR5ae81J2L1kUQKTMt5Gino3Hx1NyTudC85K/" class="header-icon" id="genesisBtn" title="Version Genesis">üå±</a>
                <span class="header-icon" id="evolutionCounter" title="√âvolutions depuis Genesis">üîÑ 2</span>
            </div>
        </div>
    </div>
    <div class="container">
        <div id="content" class="markdown-content">
            <div class="loading">‚è≥ Chargement de la documentation...</div>
        </div>
    </div>
    <div class="footer" style="border-top: 1px solid var(--border); padding: 20px; text-align: center; font-size: 0.8rem; color: #6e7681; margin-top: 40px;">

    </div>
            <script>
                marked.setOptions({ 
                    highlight: (code, lang) => lang && hljs.getLanguage(lang) ? hljs.highlight(code, { language: lang }).value : hljs.highlightAuto(code).value, 
                    breaks: true, 
                    gfm: true 
                });
                
                // Liste des fichiers .md disponibles (d√©tection automatique)
                let availableMarkdownFiles = [];
                let filesDiscoveryCache = null;
                let lastDiscoveryTime = 0;
                const DISCOVERY_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
                
                // Fonction pour extraire le titre d'un fichier markdown
                async function extractMarkdownTitle(filePath) {
                    try {
                        const response = await fetch(filePath);
                        if (!response.ok) return null;
                        
                        const content = await response.text();
                        const lines = content.split('\n');
                        
                        // Chercher le premier titre (H1, H2, ou H3)
                        for (const line of lines.slice(0, 20)) { // Limiter aux 20 premi√®res lignes
                            const trimmed = line.trim();
                            if (trimmed.startsWith('# ')) {
                                return trimmed.substring(2).trim();
                            } else if (trimmed.startsWith('## ')) {
                                return trimmed.substring(3).trim();
                            } else if (trimmed.startsWith('### ')) {
                                return trimmed.substring(4).trim();
                            }
                        }
                        
                        // Chercher une ligne qui ressemble √† un titre (premi√®re ligne non vide significative)
                        for (const line of lines.slice(0, 10)) {
                            const trimmed = line.trim();
                            if (trimmed.length > 0 && 
                                !trimmed.startsWith('---') && 
                                !trimmed.startsWith('```') &&
                                !trimmed.startsWith('*') &&
                                !trimmed.startsWith('-') &&
                                trimmed.length < 100) { // Pas trop long pour √™tre un titre
                                return trimmed.replace(/[*_`]/g, ''); // Nettoyer le markdown
                            }
                        }
                        
                        // Fallback : utiliser le nom du fichier
                        return filePath.split('/').pop().replace('.md', '');
                    } catch (error) {
                        return filePath.split('/').pop().replace('.md', '');
                    }
                }
                
                // Fonction pour d√©couvrir dynamiquement tous les fichiers .md
                async function discoverMarkdownFiles() {
                    availableMarkdownFiles = [];
                    const discoveredFiles = new Set();
                    
                    console.log('üîç D√©couverte dynamique des fichiers .md...');
                    
                    // Fonction r√©cursive pour explorer les r√©pertoires
                    async function exploreDirectory(basePath = '') {
                        try {
                            // Essayer de r√©cup√©rer un listing de r√©pertoire via une requ√™te sp√©ciale
                            // En IPFS, on peut parfois lister le contenu d'un r√©pertoire
                            const response = await fetch(basePath || './', { method: 'GET' });
                            if (response.ok) {
                                const html = await response.text();
                                
                                // Parser le HTML pour extraire les liens vers les fichiers .md
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(html, 'text/html');
                                const links = doc.querySelectorAll('a[href]');
                                
                                for (const link of links) {
                                    const href = link.getAttribute('href');
                                    if (href && !href.startsWith('http') && !href.startsWith('#')) {
                                        const fullPath = basePath ? `${basePath}/${href}` : href;
                                        
                                        if (href.endsWith('.md')) {
                                            discoveredFiles.add(fullPath);
                                        } else if (!href.includes('.') && !href.endsWith('/')) {
                                            // Potentiel r√©pertoire, explorer r√©cursivement
                                            await exploreDirectory(fullPath);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // M√©thode de listing √©chou√©e, utiliser une approche par tentatives
                        }
                    }
                    
                    // Fonction alternative : tester des fichiers et r√©pertoires communs
                    async function discoverByTesting() {
                        const commonPaths = [
                            // Fichiers racine
                            'README.md', 'INTRODUCTION.md', 'GLOSSAIRE.md', 'INDEX.md',
                            'CHANGELOG.md', 'LICENSE.md', 'CONTRIBUTING.md',
                            
                            // Patterns de nommage IA
                            'Readme.gpt.md', 'Readme.deepseek.md', 'Readme.claude.md', 
                            'Readme.gemini.md', 'Readme.mistral.md', 'Readme.llama.md',
                            
                            // Patterns avec pr√©fixes
                            'README.Human_Galaxy_Expansion.md', 'README.Theory.md',
                            'IPFS_GUIDE.md', 'NOSTR_GUIDE.md', 'API_GUIDE.md',
                            
                            // R√©pertoires communs
                            'docs/', 'doc/', 'documentation/', 'guide/', 'guides/',
                            'examples/', 'example/', 'demo/', 'demos/',
                            'experience/', 'experiments/', 'test/', 'tests/',
                            'src/', 'lib/', 'tools/', 'scripts/',
                            'research/', 'theory/', 'simulation/', 'simulations/'
                        ];
                        
                        // Tester les fichiers directs
                        for (const path of commonPaths) {
                            if (path.endsWith('.md')) {
                                try {
                                    const response = await fetch(path, { method: 'HEAD' });
                                    if (response.ok) {
                                        discoveredFiles.add(path);
                                    }
                                } catch (e) {
                                    // Fichier non accessible
                                }
                            }
                        }
                        
                        // Tester les r√©pertoires
                        for (const dir of commonPaths.filter(p => p.endsWith('/'))) {
                            const dirPath = dir.slice(0, -1); // Enlever le slash final
                            
                            // Tester quelques fichiers communs dans ce r√©pertoire
                            const commonFiles = [
                                'README.md', 'index.md', 'INDEX.md', 'main.md',
                                'introduction.md', 'overview.md', 'guide.md'
                            ];
                            
                            for (const file of commonFiles) {
                                try {
                                    const fullPath = `${dirPath}/${file}`;
                                    const response = await fetch(fullPath, { method: 'HEAD' });
                                    if (response.ok) {
                                        discoveredFiles.add(fullPath);
                                    }
                                } catch (e) {
                                    // Fichier non accessible
                                }
                            }
                            
                            // Tester des patterns de nommage dans les r√©pertoires
                            const patterns = ['Ex.1.md', 'Ex.2.md', 'Ex.3.md', 'ESchema.md', 'Setup.md'];
                            for (const pattern of patterns) {
                                try {
                                    const fullPath = `${dirPath}/${pattern}`;
                                    const response = await fetch(fullPath, { method: 'HEAD' });
                                    if (response.ok) {
                                        discoveredFiles.add(fullPath);
                                    }
                                } catch (e) {
                                    // Fichier non accessible
                                }
                            }
                        }
                    }
                    
                    // Essayer d'abord l'exploration de r√©pertoire
                    await exploreDirectory();
                    
                    // Compl√©ter avec la m√©thode de test
                    await discoverByTesting();
                    
                    console.log(`üìÅ ${discoveredFiles.size} fichiers .md d√©couverts dynamiquement`);
                    
                    // Traiter tous les fichiers d√©couverts
                    for (const file of discoveredFiles) {
                        try {
                            const title = await extractMarkdownTitle(file);
                            availableMarkdownFiles.push({
                                path: file,
                                title: title,
                                directory: file.includes('/') ? file.substring(0, file.lastIndexOf('/')) : null
                            });
                        } catch (e) {
                            console.warn(`‚ö†Ô∏è Erreur lors du traitement de ${file}:`, e);
                        }
                    }
                    
                    // S'assurer que README.md est en premier, puis grouper par r√©pertoire
                    availableMarkdownFiles.sort((a, b) => {
                        if (a.path === 'README.md') return -1;
                        if (b.path === 'README.md') return 1;
                        
                        // Grouper par r√©pertoire
                        if (a.directory !== b.directory) {
                            if (!a.directory) return -1; // Fichiers racine en premier
                            if (!b.directory) return 1;
                            return a.directory.localeCompare(b.directory);
                        }
                        
                        return a.title.localeCompare(b.title);
                    });
                    
                    console.log(`‚úÖ Navigation g√©n√©r√©e avec ${availableMarkdownFiles.length} fichiers`);
                }
                
                // Fonction pour basculer l'affichage du menu
                function toggleNavMenu() {
                    const dropdown = document.getElementById('navDropdown');
                    dropdown.classList.toggle('show');
                }
                
                // Fermer le menu si on clique ailleurs
                document.addEventListener('click', function(event) {
                    const navMenu = document.querySelector('.nav-menu');
                    const dropdown = document.getElementById('navDropdown');
                    if (!navMenu.contains(event.target)) {
                        dropdown.classList.remove('show');
                    }
                });
                
                // Populer le menu de navigation
                async function populateNavMenu() {
                    // V√©rifier le cache avant de red√©couvrir
                    const now = Date.now();
                    if (filesDiscoveryCache && (now - lastDiscoveryTime) < DISCOVERY_CACHE_DURATION) {
                        console.log('üìã Utilisation du cache de d√©couverte des fichiers');
                        availableMarkdownFiles = filesDiscoveryCache;
                    } else {
                        // D'abord d√©couvrir les fichiers disponibles
                        await discoverMarkdownFiles();
                        // Mettre en cache
                        filesDiscoveryCache = [...availableMarkdownFiles];
                        lastDiscoveryTime = now;
                    }
                    
                    const dropdown = document.getElementById('navDropdown');
                    dropdown.innerHTML = '';
                    
                    if (availableMarkdownFiles.length === 0) {
                        const noFiles = document.createElement('span');
                        noFiles.textContent = 'üìÑ Aucun fichier .md trouv√©';
                        noFiles.style.padding = '8px 12px';
                        noFiles.style.color = '#8b949e';
                        dropdown.appendChild(noFiles);
                        return;
                    }
                    
                    // Grouper les fichiers par r√©pertoire
                    const filesByDirectory = {};
                    
                    availableMarkdownFiles.forEach(fileObj => {
                        const directory = fileObj.directory || 'root';
                        if (!filesByDirectory[directory]) {
                            filesByDirectory[directory] = [];
                        }
                        filesByDirectory[directory].push(fileObj);
                    });
                    
                    // Traiter d'abord les fichiers racine
                    if (filesByDirectory['root']) {
                        filesByDirectory['root'].forEach(fileObj => {
                            const link = document.createElement('a');
                            link.href = '#';
                            
                            // Nom d'affichage avec titre
                            let displayName;
                            if (fileObj.path === 'README.md') {
                                displayName = 'üè† ' + fileObj.title;
                            } else if (fileObj.path.startsWith('Readme.')) {
                                const aiName = fileObj.path.replace('Readme.', '').replace('.md', '');
                                displayName = 'ü§ñ ' + fileObj.title + ' (' + aiName + ')';
                            } else {
                                displayName = 'üìÑ ' + fileObj.title;
                            }
                            
                            link.textContent = displayName;
                            link.onclick = function(e) {
                                e.preventDefault();
                                if (fileObj.path === 'README.md') {
                                    loadReadme();
                                } else {
                                    loadMarkdownFile(fileObj.path);
                                }
                                dropdown.classList.remove('show');
                            };
                            
                            dropdown.appendChild(link);
                        });
                    }
                    
                    // Traiter les r√©pertoires
                    Object.keys(filesByDirectory).forEach(directory => {
                        if (directory === 'root') return; // D√©j√† trait√©
                        
                        // Cr√©er un s√©parateur/titre de section
                        const sectionTitle = document.createElement('div');
                        sectionTitle.className = 'nav-section-title';
                        sectionTitle.textContent = `üìÅ ${directory.charAt(0).toUpperCase() + directory.slice(1)}`;
                        dropdown.appendChild(sectionTitle);
                        
                        // Ajouter les fichiers du r√©pertoire
                        filesByDirectory[directory].forEach(fileObj => {
                            const link = document.createElement('a');
                            link.href = '#';
                            link.className = 'nav-subsection';
                            
                            // Nom d'affichage avec titre
                            const displayName = 'üìÑ ' + fileObj.title;
                            
                            link.textContent = displayName;
                            link.onclick = function(e) {
                                e.preventDefault();
                                loadMarkdownFile(fileObj.path);
                                dropdown.classList.remove('show');
                            };
                            
                            dropdown.appendChild(link);
                        });
                    });
                }
            
            // Fonction pour g√©n√©rer des IDs apr√®s le rendu
            function addHeadingIds(html) {
                return html.replace(/<h([1-6])([^>]*)>(.*?)<\/h[1-6]>/gi, function(match, level, attrs, text) {
                    // V√©rifier si l'ID existe d√©j√†
                    if (attrs.includes('id=')) {
                        return match;
                    }
                    
                    // G√©n√©rer un ID √† partir du texte
                    const cleanText = text.replace(/<[^>]*>/g, ''); // Supprimer HTML
                    const id = cleanText
                        .toLowerCase()
                        .replace(/[^\w\s-]/g, '') // Supprimer caract√®res sp√©ciaux
                        .replace(/\s+/g, '-')     // Remplacer espaces par tirets
                        .replace(/-+/g, '-')      // √âviter tirets multiples
                        .replace(/^-|-$/g, '');   // Supprimer tirets en d√©but/fin
                    
                    return `<h${level}${attrs} id="${id}">${text}</h${level}>`;
                });
            }
        
            // Fonction pour mettre √† jour la navigation (breadcrumb et bouton retour)
            function updateNavigation(filename, anchor) {
                const backBtn = document.getElementById('backBtn');
                const breadcrumbText = document.getElementById('breadcrumbText');
                
                if (filename === 'README.md') {
                    backBtn.style.display = 'none';
                    breadcrumbText.textContent = anchor ? ` ‚Üí README ${anchor}` : ' ‚Üí README';
                } else {
                    backBtn.style.display = 'inline-block';
                    const shortName = filename.replace('.md', '').replace('Readme.', '').replace('README.', '');
                    breadcrumbText.textContent = anchor ? ` ‚Üí ${shortName} ${anchor}` : ` ‚Üí ${shortName}`;
                }
            }
        
        async function loadReadme() {
            const content = document.getElementById('content');
            try {
                const response = await fetch('README.md');
                if (!response.ok) throw new Error(`Erreur ${response.status}`);
                const markdown = await response.text();
                
                // Parser le markdown
                let html = marked.parse(markdown);
                
                // Ajouter les IDs aux titres
                html = addHeadingIds(html);
                
                // Transformer les liens .md en liens qui rechargent dans la m√™me page
                // G√©rer les liens avec ancres : fichier.md#ancre
                html = html.replace(/href="([^"]+\.md)(#[^"]+)?"/g, function(match, file, anchor) {
                    anchor = anchor || '';
                    return `href="#" onclick="loadMarkdownFile('${file}', '${anchor}'); return false;"`;
                });
                
                content.innerHTML = html;
                
                // Mettre √† jour la navigation
                updateNavigation('README.md', '');
                
                // Rendre les diagrammes Mermaid
                try {
                    await renderMermaidDiagrams();
                    console.log('‚úÖ Diagrammes Mermaid trait√©s dans README');
                } catch (error) {
                    console.error('‚ùå Erreur Mermaid dans README:', error);
                }
                
                // Rendu des formules math√©matiques
                if (window.renderMathInElement) {
                    renderMathInElement(content, { 
                        delimiters: [
                            {left: '$$', right: '$$', display: true}, 
                            {left: '$', right: '$', display: false},
                            {left: '\\[', right: '\\]', display: true},
                            {left: '\\(', right: '\\)', display: false}
                        ],
                        throwOnError: false,
                        errorColor: '#cc0000',
                        strict: false,
                        trust: true,
                        macros: {
                            "\\sim": "\\thicksim"
                        }
                    });
                }
                
                // G√©rer les ancres apr√®s le chargement avec d√©lai pour le rendu
                setTimeout(() => handleAnchors(), 300);
                
                // Debug : afficher les ancres disponibles dans la console
                setTimeout(() => {
                    console.log('=== ANCRES DISPONIBLES APR√àS RENDU ===');
                    document.querySelectorAll('[id]').forEach(el => {
                        console.log(`#${el.id} - "${el.textContent.trim().substring(0, 50)}..."`);
                    });
                    
                    // Debug sp√©cial pour les titres
                    console.log('=== TITRES H1-H6 ===');
                    document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(el => {
                        console.log(`${el.tagName} id="${el.id}" - "${el.textContent.trim()}"`);
                    });
                }, 800);
                
                if (window.location.search.includes('debug=anchors')) {
                    setTimeout(() => {
                        console.log('=== MODE DEBUG ANCHORS ACTIV√â ===');
                    }, 500);
                }
            } catch (error) {
                content.innerHTML = `<h1>‚ùå Erreur</h1><p>Impossible de charger README.md</p><p>D√©tails: ${error.message}</p>`;
            }
        }
        
        async function loadMarkdownFile(filename, targetAnchor = '') {
            const content = document.getElementById('content');
            content.innerHTML = '<div class="loading">‚è≥ Chargement de ' + filename + '...</div>';
            try {
                const response = await fetch(filename);
                if (!response.ok) throw new Error(`Erreur ${response.status}`);
                const markdown = await response.text();
                
                let html = marked.parse(markdown);
                
                // Ajouter les IDs aux titres
                html = addHeadingIds(html);
                
                // Mettre √† jour la navigation
                updateNavigation(filename, targetAnchor);
                
                // Transformer les liens .md avec gestion des ancres
                html = html.replace(/href="([^"]+\.md)(#[^"]+)?"/g, function(match, file, anchor) {
                    anchor = anchor || '';
                    return `href="#" onclick="loadMarkdownFile('${file}', '${anchor}'); return false;"`;
                });
                
                content.innerHTML = html;
                
                // Rendre les diagrammes Mermaid
                try {
                    await renderMermaidDiagrams();
                    console.log(`‚úÖ Diagrammes Mermaid trait√©s dans ${filename}`);
                } catch (error) {
                    console.error(`‚ùå Erreur Mermaid dans ${filename}:`, error);
                }
                
                if (window.renderMathInElement) {
                    renderMathInElement(content, { 
                        delimiters: [
                            {left: '$$', right: '$$', display: true}, 
                            {left: '$', right: '$', display: false},
                            {left: '\\[', right: '\\]', display: true},
                            {left: '\\(', right: '\\)', display: false}
                        ],
                        throwOnError: false,
                        errorColor: '#cc0000',
                        strict: false,
                        trust: true,
                        macros: {
                            "\\sim": "\\thicksim"
                        }
                    });
                }
                
                // Debug : afficher les ancres dans le fichier charg√©
                setTimeout(() => {
                    console.log(`=== ANCRES DANS ${filename} ===`);
                    document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(el => {
                        console.log(`${el.tagName} id="${el.id}" - "${el.textContent.trim()}"`);
                    });
                }, 600);
                
                // G√©rer l'ancre cible ou scroll vers le haut
                if (targetAnchor) {
                    // Mettre √† jour l'URL sans recharger la page
                    window.history.replaceState(null, null, targetAnchor);
                    setTimeout(() => {
                        const element = document.querySelector(targetAnchor);
                        if (element) {
                            scrollToElementWithOffset(element);
                        }
                    }, 200);
                } else if (window.location.hash) {
                    handleAnchors();
                } else {
                    window.scrollTo(0, 0);
                }
            } catch (error) {
                content.innerHTML = `<h1>‚ùå Erreur</h1><p>Impossible de charger ${filename}</p><p>D√©tails: ${error.message}</p>`;
            }
        }
        
        // Fonction utilitaire pour scroll vers un √©l√©ment avec offset header
        function scrollToElementWithOffset(element) {
            const header = document.querySelector('.header');
            const headerHeight = header ? header.offsetHeight + 10 : 70; // +10px de marge
            const elementPosition = element.getBoundingClientRect().top + window.pageYOffset;
            const offsetPosition = elementPosition - headerHeight;
            
            window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
            });
            
            // Effet de surbrillance
            element.style.backgroundColor = 'rgba(255, 215, 0, 0.3)';
            setTimeout(() => {
                element.style.backgroundColor = '';
            }, 3000);
        }
        
        // Fonction pour g√©rer les ancres avec retry
        function handleAnchors(retryCount = 0) {
            if (!window.location.hash) return;
            
            const maxRetries = 10;
            let targetHash = window.location.hash;
            
            // Debug : afficher l'ancre recherch√©e
            console.log(`üîç Recherche ancre: "${targetHash}" (URL d√©cod√©e: "${decodeURIComponent(targetHash)}")`);
            
            // Essayer d'abord avec l'ancre telle quelle
            let element = null;
            try {
                element = document.querySelector(targetHash);
            } catch (e) {
                console.log(`‚ùå Erreur s√©lecteur CSS: ${e.message}`);
                // Essayer avec l'ancre d√©cod√©e
                try {
                    const decodedHash = decodeURIComponent(targetHash);
                    console.log(`üîÑ Tentative avec ancre d√©cod√©e: "${decodedHash}"`);
                    element = document.querySelector(decodedHash);
                } catch (e2) {
                    console.log(`‚ùå Erreur s√©lecteur d√©cod√©: ${e2.message}`);
                    // Essayer de trouver par correspondance de texte
                    const searchText = targetHash.replace('#', '').replace(/-/g, ' ').toLowerCase();
                    console.log(`üîÑ Recherche par texte: "${searchText}"`);
                    document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(el => {
                        const elText = el.textContent.toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ');
                        const elId = el.id ? el.id.toLowerCase() : '';
                        
                        // Correspondance par texte ou par ID g√©n√©r√©
                        if (elText.includes(searchText) || 
                            searchText.includes(elText.substring(0, 10)) ||
                            elId.includes(searchText.replace(/\s+/g, '-')) ||
                            searchText.replace(/\s+/g, '-').includes(elId)) {
                            element = el;
                            console.log(`‚úÖ Correspondance trouv√©e: "${el.textContent.trim()}" (ID: ${el.id})`);
                        }
                    });
                }
            }
            
            if (element) {
                scrollToElementWithOffset(element);
                console.log(`‚úÖ Ancre trouv√©e: ${targetHash} -> "${element.textContent.trim().substring(0, 50)}..."`);
            } else if (retryCount < maxRetries) {
                // Retry avec d√©lai croissant
                const delay = 200 + (retryCount * 100);
                console.log(`‚è≥ Ancre ${targetHash} non trouv√©e, retry ${retryCount + 1}/${maxRetries} dans ${delay}ms`);
                setTimeout(() => handleAnchors(retryCount + 1), delay);
            } else {
                console.log(`‚ùå Ancre ${targetHash} introuvable apr√®s ${maxRetries} tentatives`);
                // Afficher les ancres disponibles pour debug
                console.log('üîç Ancres disponibles:');
                document.querySelectorAll('[id]').forEach(el => {
                    console.log(`  #${el.id} - "${el.textContent.trim().substring(0, 50)}..."`);
                });
            }
        }
        
        // G√©rer les changements d'ancre
        window.addEventListener('hashchange', handleAnchors);
        
        // Intercepter tous les clics sur les liens .md (d√©l√©gation d'√©v√©nements)
        document.addEventListener('click', function(e) {
            const link = e.target.closest('a[href]');
            if (!link) return;
            
            const href = link.getAttribute('href');
            const mdMatch = href.match(/^([^#]+\.md)(#.*)?$/);
            
            if (mdMatch) {
                e.preventDefault();
                const filename = mdMatch[1];
                const anchor = mdMatch[2] || '';
                loadMarkdownFile(filename, anchor);
            }
        });
        
        // Fonction pour parser l'URL et d√©tecter les liens vers des fichiers .md
        function parseInitialUrl() {
            const path = window.location.pathname;
            const hash = window.location.hash;
            
            // V√©rifier si l'URL pointe vers un fichier .md
            const mdMatch = path.match(/\/([^\/]+\.md)$/);
            if (mdMatch) {
                const filename = mdMatch[1];
                loadMarkdownFile(filename, hash);
                return true;
            }
            return false;
        }
        
            // Variables globales pour Nostr
            let nostrConnected = false;
            let userPublicKey = null;
            let userPrivateKey = null;
            
            // Fonction pour se connecter √† Nostr
            async function connectToNostr() {
                const connectBtn = document.getElementById('connectBtn');
                const copyBtn = document.getElementById('copyBtn');
                
                try {
                    connectBtn.textContent = 'üîÑ Connexion...';
                    connectBtn.disabled = true;
                    
                    // Essayer d'utiliser l'extension Nostr (NIP-07)
                    if (window.nostr) {
                        console.log('Extension Nostr d√©tect√©e');
                        userPublicKey = await window.nostr.getPublicKey();
                        nostrConnected = true;
                        
                        connectBtn.textContent = '‚úÖ Connect√©';
                        connectBtn.classList.add('connected');
                        copyBtn.disabled = false;
                        
                        console.log('Connect√© avec la cl√© publique:', userPublicKey);
                    } else {
                        // Fallback: demander une cl√© nsec
                        const nsec = prompt('Entrez votre cl√© nsec (ou installez une extension Nostr):');
                        if (nsec && nsec.startsWith('nsec1')) {
                            try {
                                const decoded = NostrTools.nip19.decode(nsec);
                                userPrivateKey = decoded.data;
                                userPublicKey = NostrTools.getPublicKey(userPrivateKey);
                                nostrConnected = true;
                                
                                connectBtn.textContent = '‚úÖ Connect√©';
                                connectBtn.classList.add('connected');
                                copyBtn.disabled = false;
                                
                                console.log('Connect√© avec cl√© manuelle, cl√© publique:', userPublicKey);
                            } catch (error) {
                                throw new Error('Cl√© nsec invalide');
                            }
                        } else {
                            throw new Error('Aucune cl√© fournie');
                        }
                    }
                } catch (error) {
                    console.error('Erreur de connexion Nostr:', error);
                    connectBtn.textContent = '‚ùå Erreur';
                    setTimeout(() => {
                        connectBtn.textContent = 'üîó Connect';
                        connectBtn.disabled = false;
                    }, 2000);
                    alert('Erreur de connexion Nostr: ' + error.message);
                }
            }
            
            // Fonction pour copier le projet vers uDRIVE
            async function copyToUDrive() {
                if (!nostrConnected || !userPublicKey) {
                    alert('Veuillez vous connecter √† Nostr d\'abord');
                    return;
                }
                
                const copyBtn = document.getElementById('copyBtn');
                const originalText = copyBtn.textContent;
                
                try {
                    copyBtn.textContent = '‚è≥ Copie...';
                    copyBtn.disabled = true;
                    
                    // D√©tecter l'URL de l'API UPlanet
                    const currentURL = new URL(window.location.href);
                    const hostname = currentURL.hostname;
                    const protocol = currentURL.protocol;
                    let port = currentURL.port;
                    
                    if (port === "8080") {
                        port = "54321";
                    }
                    
                    const uHost = hostname.replace("ipfs", "u");
                    const apiUrl = protocol + "//" + uHost + (port ? ":" + port : "");
                    
                    console.log('API UPlanet d√©tect√©e:', apiUrl);
                    
                    // Obtenir le CID actuel du projet
                    const currentCID = getCurrentProjectCID();
                    if (!currentCID) {
                        throw new Error('Impossible de d√©terminer le CID du projet');
                    }
                    
                    console.log('CID du projet √† copier:', currentCID);
                    
                    // Pr√©parer les donn√©es pour l'API
                    const copyData = {
                        project_url: currentCID,
                        npub: userPublicKey,
                        project_name: getProjectName()
                    };
                    
                    console.log('Donn√©es de copie:', copyData);
                    
                    // Appeler l'API de copie
                    const response = await fetch(apiUrl + '/api/copy_project', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(copyData)
                    });
                    
                    if (!response.ok) {
                        let errorMessage = `Erreur HTTP ${response.status}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.detail) {
                                if (typeof errorData.detail === 'string') {
                                    errorMessage = errorData.detail;
                                } else if (errorData.detail.message) {
                                    errorMessage = errorData.detail.message;
                                } else {
                                    errorMessage = JSON.stringify(errorData.detail);
                                }
                            }
                        } catch (e) {
                            // Si ce n'est pas du JSON, essayer de lire comme texte
                            try {
                                const textError = await response.text();
                                if (textError) errorMessage = textError;
                            } catch (e2) {
                                errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}`;
                            }
                        }
                        throw new Error(errorMessage);
                    }
                    
                    const result = await response.json();
                    console.log('R√©sultat de la copie:', result);
                    
                    copyBtn.textContent = '‚úÖ Copi√©!';
                    
                    // Rediriger vers le nouveau CID si disponible
                    if (result.new_cid) {
                        setTimeout(() => {
                            const newUrl = protocol + "//" + hostname + (currentURL.port ? ":" + currentURL.port : "") + "/ipfs/" + result.new_cid + "/";
                            console.log('Redirection vers:', newUrl);
                            window.location.href = newUrl;
                        }, 1500);
                    } else {
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.disabled = false;
                        }, 2000);
                    }
                    
                } catch (error) {
                    console.error('Erreur de copie:', error);
                    copyBtn.textContent = '‚ùå Erreur';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                        copyBtn.disabled = false;
                    }, 2000);
                    alert('Erreur de copie: ' + error.message);
                }
            }
            
            // Fonction utilitaire pour obtenir le CID actuel
            function getCurrentProjectCID() {
                const url = window.location.href;
                const ipfsMatch = url.match(/\/ipfs\/([a-zA-Z0-9]+)/);
                return ipfsMatch ? ipfsMatch[1] : null;
            }
            
            // Fonction utilitaire pour obtenir le nom du projet
            function getProjectName() {
                const title = document.title;
                return title.replace(/[^a-zA-Z0-9\s]/g, '').trim() || 'Projet-FRD';
            }
            
            // Initialiser Mermaid
            function initializeMermaid() {
                if (typeof mermaid !== 'undefined') {
                    mermaid.initialize({
                        startOnLoad: false,
                        theme: 'dark',
                        themeVariables: {
                            primaryColor: '#58a6ff',
                            primaryTextColor: '#f0f6fc',
                            primaryBorderColor: '#30363d',
                            lineColor: '#8b949e',
                            secondaryColor: '#21262d',
                            tertiaryColor: '#161b22',
                            background: '#0d1117',
                            mainBkg: '#21262d',
                            secondBkg: '#161b22',
                            tertiaryBkg: '#0d1117'
                        },
                        flowchart: {
                            useMaxWidth: true,
                            htmlLabels: true
                        },
                        sequence: {
                            useMaxWidth: true,
                            wrap: true
                        },
                        gantt: {
                            useMaxWidth: true
                        }
                    });
                    console.log('‚úÖ Mermaid initialis√© avec le th√®me sombre');
                } else {
                    console.warn('‚ö†Ô∏è Mermaid.js non disponible');
                }
            }
            
            // Fonction pour rendre les diagrammes Mermaid
            async function renderMermaidDiagrams() {
                if (typeof mermaid === 'undefined') {
                    console.warn('‚ö†Ô∏è Mermaid.js non charg√©, saut du rendu des diagrammes');
                    return;
                }
                
                try {
                    // Trouver tous les blocs de code mermaid
                    const mermaidBlocks = document.querySelectorAll('pre code.language-mermaid, pre code.mermaid');
                    console.log(`üîç ${mermaidBlocks.length} diagramme(s) Mermaid trouv√©(s)`);
                    
                    for (let i = 0; i < mermaidBlocks.length; i++) {
                        const block = mermaidBlocks[i];
                        const mermaidCode = block.textContent;
                        const diagramId = `mermaid-diagram-${Date.now()}-${i}`;
                        
                        // Cr√©er un conteneur pour le diagramme
                        const diagramContainer = document.createElement('div');
                        diagramContainer.className = 'mermaid-container';
                        diagramContainer.style.cssText = 'margin: 20px 0; padding: 20px; background: #161b22; border-radius: 8px; border: 1px solid #30363d; text-align: center;';
                        
                        try {
                            // Rendre le diagramme Mermaid
                            const { svg } = await mermaid.render(diagramId, mermaidCode);
                            diagramContainer.innerHTML = svg;
                            
                            // Remplacer le bloc de code par le diagramme rendu
                            block.parentElement.parentElement.replaceChild(diagramContainer, block.parentElement);
                            
                            console.log(`‚úÖ Diagramme Mermaid ${i + 1} rendu avec succ√®s`);
                        } catch (error) {
                            console.error(`‚ùå Erreur rendu diagramme Mermaid ${i + 1}:`, error);
                            
                            // En cas d'erreur, afficher le code avec un message d'erreur
                            diagramContainer.innerHTML = `
                                <div style="color: #f85149; font-family: monospace; font-size: 0.9em;">
                                    <strong>‚ùå Erreur rendu Mermaid:</strong><br>
                                    ${error.message || 'Erreur inconnue'}<br><br>
                                    <details style="text-align: left;">
                                        <summary>Code source:</summary>
                                        <pre style="background: #0d1117; padding: 10px; border-radius: 4px; margin-top: 10px;">${mermaidCode}</pre>
                                    </details>
                                </div>
                            `;
                            block.parentElement.parentElement.replaceChild(diagramContainer, block.parentElement);
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Erreur g√©n√©rale lors du rendu Mermaid:', error);
                }
            }
            
            // Charger README.md au d√©marrage ou le fichier sp√©cifi√© dans l'URL
            document.addEventListener('DOMContentLoaded', () => {
                // Initialiser Mermaid
                initializeMermaid();
                
                // Populer le menu de navigation
                populateNavMenu();
                
                if (!parseInitialUrl()) {
                    loadReadme();
                    // G√©rer l'ancre initiale apr√®s un d√©lai plus long pour le rendu complet
                    setTimeout(() => handleAnchors(), 800);
                }
            });
    </script>
</body>
</html>
